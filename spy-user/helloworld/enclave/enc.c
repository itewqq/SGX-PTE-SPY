// Copyright (c) Open Enclave SDK contributors.
// Licensed under the MIT License.

#include <stdio.h>
#include <openssl/rand.h>

// Include the trusted helloworld header that is generated
// during the build. This file is generated by calling the
// sdk tool oeedger8r against the helloworld.edl file.
#include "helloworld_t.h"

#define TRACE_ENCLAVE(fmt, ...) \
    printf("Enclave: %s(%d): " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)

uint64_t BUF[6][0x2000];

uint64_t leak_func(uint64_t *a, uint64_t *b, int secret){
    uint64_t res = BUF[3][secret]; // trigger the monitor
    if(secret==0){
        res += a[secret];
        // for(volatile int i = 0;i<=0x1000000; i++){
        //     res *= 998244353;
        // }
    }else{
        res += b[secret];
        // for(volatile int i = 0;i<=0x1000000; i++){
        //     res *= 1e9+7;
        // }
    }
    return res;
}

// This is the function that the host calls. It prints
// a message in the enclave before calling back out to
// the host to print a message from there too.
void enclave_helloworld()
{
    // Print a message from the enclave. Note that this
    // does not directly call fprintf, but calls into the
    // host and calls fprintf from there. This is because
    // the fprintf function is not part of the enclave
    // as it requires support from the kernel.
    int key = 0;
    int ret = 0;
    uint64_t res = 0;
    uint64_t *A=BUF[1], *B=BUF[2], *C=BUF[3]; 
    fprintf(stdout, "Now in the enclave\n");

    
    fprintf(stdout, "Init..\n");
    if (!(ret = RAND_bytes((unsigned char *)A, 0x10)))
    {
        TRACE_ENCLAVE("RAND_bytes failed with return code %d", ret);
        goto exit;
    }  
    if (!(ret = RAND_bytes((unsigned char *)B, 0x10)))
    {
        TRACE_ENCLAVE("RAND_bytes failed with return code %d", ret);
        goto exit;
    }
    if (!(ret = RAND_bytes((unsigned char *)C, 0x10)))
    {
        TRACE_ENCLAVE("RAND_bytes failed with return code %d", ret);
        goto exit;
    }
    fprintf(stdout, "The target address: A: %p\tB: %p\tC: %p\n", A, B, C);
    
    host_start_attack();

    fprintf(stdout, "Run the leaking function...\n");
    for(int i=0;i<20;i++){
        if (!(ret = RAND_bytes((unsigned char *)(&key), 1)))
        {
            TRACE_ENCLAVE("RAND_bytes failed with return code %d", ret);
            goto exit;
        }
        key %= 2;
        res = leak_func(A, B, key);
        fprintf(stdout, "[DEBUG] %dth key is %d, res:%lu\n", i+1, key, res);
    }

    // Call back into the host
    oe_result_t result = host_helloworld();
    if (result != OE_OK)
    {
        fprintf(
            stderr,
            "Call to host_helloworld failed: result=%u (%s)\n",
            result,
            oe_result_str(result));
    }
exit:
    return;
}
